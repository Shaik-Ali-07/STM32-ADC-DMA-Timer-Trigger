/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
//
//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif
#include<stm32f411xe.h>

volatile uint32_t adc_value = 0;

void Init(void){
	RCC->CR |= RCC_CR_HSEON; //SRC HSE
	while(!(RCC->CR & RCC_CR_HSERDY));

	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_VOS; //voltage scaling in pwr

	//FLASH CONFIG
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;

	// pll configuration n,m,p&q and clock Source
	RCC->PLLCFGR |= (25 << 0)  |
					(200 << 6) |
					(0 << 16)  |
					(4 << 25)  |
					RCC_PLLCFGR_PLLSRC_HSE;

	//AHB APB1 APB2 Prescaler
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));

	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL); //wait till it is switched
}



void TIM2_Init(void){
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	//timer 2 set to 100hz
	TIM2->PSC = 1000-1; // prescaler 999
	TIM2->ARR = 1000-1; //auto reload 999


	TIM2->CR2 &= ~TIM_CR2_MMS;
	TIM2->CR2 |= (0x2 << 4); // MMS bits (010) TRGO

	TIM2->CR1 |= TIM_CR1_CEN;
}

void GPIO_Init(void){
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER |= (3U << (0 * 2));
}
void USART6_Init(void){
	// Enable Clocks FIRST
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	RCC->APB2ENR |= RCC_APB2ENR_USART6EN;

	// Configure GPIO PA11
	GPIOA->MODER &= ~(3U << (11 * 2));
	GPIOA->MODER |=  (2U << (11 * 2)); // AF Mode
	GPIOA->OSPEEDR |= (3U << (11 * 2)); // High Speed

	//Set Alternate Function AF8
	GPIOA->AFR[1] &= ~(0xFU << (12));
	GPIOA->AFR[1] |=  (8U << (12));

	// Reset USART6 to clear any error states
	USART6->CR1 = 0;
	// Baud Rate (115200 @ 100MHz)
	USART6->BRR = 868;
	USART6->CR1 |= USART_CR1_TE | USART_CR1_UE;
}

int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++) {

        // 2. Output to USART6 low level
        while (!(USART6->SR & USART_SR_TXE));
        USART6->DR = (*ptr++ & 0xFF);
    }
    return len;
}

void DMA_Init(void){
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;
	while(DMA2_Stream0->CR & DMA_SxCR_EN);

	DMA2->LIFCR = (0x3D << 0);

	DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;
	DMA2_Stream0->M0AR = (uint32_t)&adc_value;
	DMA2_Stream0->NDTR = 1;

	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;
	DMA2_Stream0->CR |= (1U << 13) | (1U << 11) | DMA_SxCR_CIRC | DMA_SxCR_MINC;
	DMA2_Stream0->CR |= DMA_SxCR_EN;
}

void ADC_Init(void){
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
	ADC1->SQR3 = 0;//NUMBER OF REGULAR CONVERSIONS

	ADC1->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_EXTSEL);
	ADC1->CR2 |= (1U << 28);       // Trigger on Rising Edge Set to 01
	ADC1->CR2 |= (6U << 24);       // TIM2_TRGO selection Set to 0110

	ADC1->CR2 |= ADC_CR2_DMA | ADC_CR2_DDS; //DMA ENABLE AND CONTIOUS MODE
	ADC1->CR2 &= ~ADC_CR2_CONT;
	ADC1->CR2 |= ADC_CR2_ADON;


	for(int i=0; i<1000; i++);
	ADC1->CR2 |= ADC_CR2_SWSTART;

}

int main(void)
{
    Init();
    GPIO_Init();
    DMA_Init();
    TIM2_Init();
    ADC_Init();
    USART6_Init();




    while(1){
    	if (DMA2->LISR & DMA_LISR_TCIF0) {

    	DMA2->LIFCR |= DMA_LIFCR_CTCIF0;

    	printf("ADC: %lu\r\n", adc_value);

    	}
    }
}
